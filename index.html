<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Match Cut | Arnavsocial</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { 
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        background: '#f5f5f7',
                        surface: '#ffffff',
                        primary: '#000000',
                    },
                    borderRadius: {
                        'squircle': '22px',
                    },
                    transitionTimingFunction: {
                        'spring': 'cubic-bezier(0.25, 0.8, 0.25, 1)',
                    }
                }
            }
        }
    </script>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <style>
        body { background-color: #f5f5f7; color: #1d1d1f; overflow: hidden; }
        
        /* THE TEXTURE: Deep Blue Nebula */
        .texture-bg {
            background: radial-gradient(circle at 20% 0%, #1e40af 0%, #0f172a 60%, #020617 100%);
            box-shadow: 0 4px 20px rgba(15, 23, 42, 0.4);
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* Apple-style smooth corners */
        .squircle {
            border-radius: 20px;
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none; 
            width: 100%; 
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #3b82f6, #0f172a);
            cursor: pointer;
            margin-top: -10px; 
            border: 2px solid #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
            transition: transform 0.15s ease;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.15); }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e5e5;
            border-radius: 999px;
        }

        /* --- CIRCULAR CHECKBOX --- */
        .checkbox-circle {
            appearance: none;
            width: 28px;
            height: 28px;
            border: 2px solid #e5e7eb; /* gray-200 */
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            background-color: white;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .checkbox-circle:hover {
            border-color: #94a3b8;
            transform: scale(1.05);
        }

        .checkbox-circle:checked {
            border-color: transparent;
            /* Using the texture-bg logic directly via class in React, or applying here */
            background: radial-gradient(circle at 20% 0%, #1e40af 0%, #0f172a 60%, #020617 100%);
            box-shadow: 0 2px 8px rgba(30, 64, 175, 0.3);
        }

        /* Checkmark Icon handled via SVG in React, but we can fake it with CSS */
        .checkbox-circle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 8px;
            border-left: 2.5px solid white;
            border-bottom: 2.5px solid white;
            transform: translate(-50%, -60%) rotate(-45deg) scale(0);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            opacity: 0;
        }

        .checkbox-circle:checked::after {
            transform: translate(-50%, -60%) rotate(-45deg) scale(1);
            opacity: 1;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 0px; background: transparent; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const IconPlay = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const IconPause = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const IconLoader = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="animate-spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>;
        const IconSparkles = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/></svg>;
        const IconCrop = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 2v14a2 2 0 0 0 2 2h14"/><path d="M18 22V8a2 2 0 0 0-2-2H2"/></svg>;
        const IconGhost = () => <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="black" stroke="none"><path d="M9 22H15C20 22 22 19 22 15V7C22 4 20 2 15 2H9C4 2 2 4 2 7V15C2 19 4 22 9 22Z" opacity="0.4"/><path d="M15.75 12C15.75 12.41 15.41 12.75 15 12.75H9C8.59 12.75 8.25 12.41 8.25 12C8.25 11.59 8.59 11.25 9 11.25H15C15.41 11.25 15.75 11.59 15.75 12Z"/><circle cx="10" cy="9" r="1"/><circle cx="14" cy="9" r="1"/></svg>;
        
        // --- SOCIAL ICONS ---
        const SocialIcon = ({ type }) => {
            const classes = "w-10 h-10 squircle bg-white shadow-sm border border-gray-100 flex items-center justify-center hover:shadow-md hover:-translate-y-1 transition-all duration-300 ease-spring cursor-pointer overflow-hidden group";
            
            if (type === 'github') return (
                <a href="https://github.com/arnavsocial" target="_blank" className={classes} title="GitHub">
                    <svg viewBox="0 0 24 24" width="22" height="22" fill="#181717" className="group-hover:opacity-80 transition-opacity"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.419-1.305.763-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
                </a>
            );
            
            if (type === 'instagram') return (
                <a href="https://www.instagram.com/arnavsocial/" target="_blank" className={classes} title="Instagram">
                    <svg viewBox="0 0 24 24" width="22" height="22" fill="none">
                        <defs>
                            <linearGradient id="instaGrad" x1="2" y1="22" x2="22" y2="2" gradientUnits="userSpaceOnUse">
                                <stop offset="0" stopColor="#FFD600"/>
                                <stop offset="0.25" stopColor="#FF7A00"/>
                                <stop offset="0.5" stopColor="#FF0069"/>
                                <stop offset="0.75" stopColor="#D300C5"/>
                                <stop offset="1" stopColor="#7638FA"/>
                            </linearGradient>
                        </defs>
                        <rect x="2" y="2" width="20" height="20" rx="5" ry="5" stroke="url(#instaGrad)" strokeWidth="2"/>
                        <circle cx="12" cy="12" r="3.5" stroke="url(#instaGrad)" strokeWidth="2"/>
                        <circle cx="17.5" cy="6.5" r="1.5" fill="url(#instaGrad)"/>
                    </svg>
                </a>
            );
            
            // --- UPDATED: High Quality Gmail Vector ---
            if (type === 'gmail') return (
                <a href="potato" target="_blank" className={classes} title="Gmail">
                    <svg viewBox="0 0 24 24" width="22" height="22">
                        <path d="M19.5 3h-3v8.32L12 14.2 7.5 11.32V3h-3C3.12 3 2 4.12 2 5.5v13C2 19.88 3.12 21 4.5 21h3v-7l4.5 2.5 4.5-2.5v7h3c1.38 0 2.5-1.12 2.5-2.5v-13C22 4.12 20.88 3 19.5 3z" fill="#E1E1E1"/>
                        <path d="M19.5 3h-3v8.32L12 14.2 7.5 11.32V3h-3C3.12 3 2 4.12 2 5.5v.5c0-1.38 1.12-2.5 2.5-2.5h3v8.32L12 14.7l4.5-2.88V3.5h3c1.38 0 2.5 1.12 2.5 2.5v-.5c0-1.38-1.12-2.5-2.5-2.5z" fill="#E1E1E1" opacity=".2"/>
                        <path d="M22 18.5v-13c0-1.38-1.12-2.5-2.5-2.5h-3v8.32L12 14.2 7.5 11.32V3h-3C3.12 3 2 4.12 2 5.5v13c0 1.38 1.12 2.5 2.5 2.5h3v-7l4.5 2.5 4.5-2.5v7h3c1.38 0 2.5-1.12 2.5-2.5z" fill="none"/>
                        <path d="M19.5 3H15v8.32L12 14.2 9 12.28V3H4.5C3.12 3 2 4.12 2 5.5v13C2 19.88 3.12 21 4.5 21H9v-7l3 1.67L15 14v7h4.5c1.38 0 2.5-1.12 2.5-2.5v-13C22 4.12 20.88 3 19.5 3z" fill="#fff" opacity=".3" style={{display:'none'}}/>
                        <path fill="#4285F4" d="M4.5 3C3.12 3 2 4.12 2 5.5v13c0 1.38 1.12 2.5 2.5 2.5H7v-7l-5-3.5V5.5c0-.46.12-.89.34-1.26L7 7.5V3H4.5z"/>
                        <path fill="#34A853" d="M17 7.5l4.66-3.26c.22.37.34.8.34 1.26v5.5l-5 3.5v7h2.5c1.38 0 2.5-1.12 2.5-2.5v-13c0-1.38-1.12-2.5-2.5-2.5H17v3z"/>
                        <path fill="#FBBC04" d="M2 10.5l5 3.5 5-3.15 5 3.15 5-3.5V5.5C22 4.12 20.88 3 19.5 3h-3v4.5L12 10.42 7.5 7.5V3h-3C3.12 3 2 4.12 2 5.5v5z"/>
                        <path fill="#EA4335" d="M12 10.42L16.5 7.5V3H12v7.42zm0 0L7.5 7.5V3H12v7.42z"/>
                    </svg>
                </a>
            );
            return null;
        };

        const RATIOS = {
            '1:1': { w: 1024, h: 1024, aspect: 'aspect-square' },
            '9:16': { w: 1080, h: 1920, aspect: 'aspect-[9/16]' },
            '16:9': { w: 1920, h: 1080, aspect: 'aspect-[16/9]' },
            'Free': { w: 2048, h: 2048, aspect: 'aspect-square' } // 2K Square
        };

        const gifWorkerBlob = new Blob([`importScripts('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');`], { type: 'application/javascript' });
        const gifWorkerUrl = URL.createObjectURL(gifWorkerBlob);
        const getDistance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        function App() {
            // State
            const [images, setImages] = useState([]);
            const [status, setStatus] = useState('idle');
            const [previewIndex, setPreviewIndex] = useState(0);
            const [isPlaying, setIsPlaying] = useState(true);
            const [exportProgress, setExportProgress] = useState(0);
            const [isDragging, setIsDragging] = useState(false);
            
            // Settings
            const [speed, setSpeed] = useState(0.2);
            const [layoutScale, setLayoutScale] = useState(50);
            const [ratio, setRatio] = useState('1:1');
            const [format, setFormat] = useState('GIF');
            const [showGuides, setShowGuides] = useState(true);
            const [cropMode, setCropMode] = useState('smart');
            const [modelReady, setModelReady] = useState(false);

            // Refs
            const canvasRef = useRef(null);
            const faceMeshRef = useRef(null);
            const processingQueueRef = useRef([]);
            const fileInputRef = useRef(null);

            const validImages = useMemo(() => images.filter(i => i.status === 'ready'), [images]);

            // 1. Init
            useEffect(() => {
                const initModel = async () => {
                    try {
                        const faceMesh = new FaceMesh({
                            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
                        });
                        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.1, minTrackingConfidence: 0.1 });
                        faceMesh.onResults(handleResults);
                        await faceMesh.initialize();
                        faceMeshRef.current = faceMesh;
                        setModelReady(true);
                    } catch (e) { console.error("AI Init Failed", e); }
                };
                initModel();
            }, []);

            // 2. Draw
            const drawFrame = useCallback((ctx, imgData, w, h, renderGuides) => {
                ctx.fillStyle = '#121212';
                ctx.fillRect(0, 0, w, h);

                if (!imgData || !imgData.img) return;

                if (imgData.landmarks) {
                    const { img, landmarks } = imgData;
                    const { leftEye, rightEye } = landmarks;

                    const p1 = { x: leftEye.x * img.width, y: leftEye.y * img.height };
                    const p2 = { x: rightEye.x * img.width, y: rightEye.y * img.height };
                    const srcDist = getDistance(p1, p2);
                    const srcMid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                    const srcAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                    const tgtMid = { x: w * 0.5, y: h * 0.5 };
                    const baseCoverage = 0.20; 
                    const scaleModifier = layoutScale / 50; 
                    const tgtDist = w * (baseCoverage * scaleModifier);

                    const scale = tgtDist / srcDist;
                    const rotation = cropMode === 'smart' ? -srcAngle : 0;

                    ctx.save();
                    ctx.translate(tgtMid.x, tgtMid.y);
                    ctx.rotate(rotation);
                    ctx.scale(scale, scale);
                    ctx.translate(-srcMid.x, -srcMid.y);
                    
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 40;
                    ctx.shadowOffsetY = 10;

                    ctx.drawImage(img, 0, 0);
                    ctx.restore();

                    // Check 'renderGuides' arg instead of 'showGuides' state
                    if (renderGuides) {
                        ctx.save();
                        ctx.strokeStyle = '#22d3ee';
                        ctx.lineWidth = 2 * (1/scaleModifier); 
                        ctx.globalAlpha = 0.5;
                        const eyeOffset = tgtDist / 2;
                        
                        ctx.beginPath(); ctx.arc(tgtMid.x - eyeOffset, tgtMid.y, 10, 0, Math.PI * 2); ctx.stroke();
                        ctx.beginPath(); ctx.arc(tgtMid.x + eyeOffset, tgtMid.y, 10, 0, Math.PI * 2); ctx.stroke();
                        ctx.restore();
                    }

                } else {
                    const img = imgData.img;
                    const scale = Math.min(w / img.width, h / img.height);
                    const x = (w - img.width * scale) / 2;
                    const y = (h - img.height * scale) / 2;
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                }
            }, [layoutScale, cropMode]); 

            // 3. Process
            const processImages = async (queue) => {
                if (!faceMeshRef.current || !modelReady) return;
                setStatus('processing');
                for (let img of queue) {
                    if (img.status !== 'pending') continue;
                    processingQueueRef.current = img.id;
                    setImages(prev => prev.map(i => i.id === img.id ? { ...i, status: 'processing' } : i));
                    try { await faceMeshRef.current.send({ image: img.img }); await new Promise(r => setTimeout(r, 50)); } catch(e) {}
                }
                setStatus('idle');
            };

            const handleResults = (results) => {
                const currentId = processingQueueRef.current;
                if (!currentId) return;
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const lm = results.multiFaceLandmarks[0];
                    let leftEye, rightEye;
                    if (lm.length > 468) { leftEye = lm[468]; rightEye = lm[473]; } else { leftEye = { x: (lm[33].x + lm[133].x)/2, y: (lm[33].y + lm[133].y)/2 }; rightEye = { x: (lm[362].x + lm[263].x)/2, y: (lm[362].y + lm[263].y)/2 }; }
                    setImages(prev => prev.map(img => img.id === currentId ? { ...img, status: 'ready', landmarks: { leftEye, rightEye } } : img));
                    processingQueueRef.current = null; 
                } else {
                    setImages(prev => prev.map(img => img.id === currentId ? { ...img, status: 'error' } : img));
                }
            };

            const handleFiles = async (files) => {
                const validFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
                if (validFiles.length === 0) return;
                const newImages = [];
                for (const file of validFiles) {
                    const src = await new Promise(r => { const reader = new FileReader(); reader.onload = e => r(e.target.result); reader.readAsDataURL(file); });
                    const img = new Image(); img.src = src; await new Promise(r => img.onload = r);
                    newImages.push({ id: Math.random().toString(36).substr(2, 9), src, img, status: 'pending' });
                }
                const updated = [...images, ...newImages];
                setImages(updated);
                processImages(updated);
            };

            const onDrop = (e) => { e.preventDefault(); setIsDragging(false); handleFiles(e.dataTransfer.files); };
            const handleDragEnter = (e) => { e.preventDefault(); setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const dims = RATIOS[ratio];
                canvas.width = dims.w; canvas.height = dims.h;
                if (validImages.length === 0) { ctx.fillStyle = '#171717'; ctx.fillRect(0, 0, dims.w, dims.h); return; }
                const safeIndex = previewIndex % validImages.length;
                // Pass 'showGuides' state during preview
                drawFrame(ctx, validImages[safeIndex], dims.w, dims.h, showGuides);
                if (isPlaying && validImages.length > 1) {
                    const timeout = setTimeout(() => { setPreviewIndex(prev => (prev + 1) % validImages.length); }, speed * 1000);
                    return () => clearTimeout(timeout);
                }
            }, [validImages, previewIndex, isPlaying, speed, ratio, cropMode, showGuides, layoutScale, drawFrame]);

            const handleExport = async () => {
                if (validImages.length === 0) return;
                setStatus('exporting'); setExportProgress(0); setIsPlaying(false);
                const dims = RATIOS[ratio];
                const canvas = document.createElement('canvas'); canvas.width = dims.w; canvas.height = dims.h; const ctx = canvas.getContext('2d');
                try {
                    // Pass 'false' for guides during export
                    if (format === 'GIF') {
                        const gif = new GIF({ workers: 2, quality: 10, workerScript: gifWorkerUrl, width: dims.w, height: dims.h });
                        validImages.forEach(img => { 
                            drawFrame(ctx, img, dims.w, dims.h, false); // No guides
                            gif.addFrame(ctx, { copy: true, delay: speed * 1000 }); 
                        });
                        gif.on('progress', p => setExportProgress(Math.round(p * 100)));
                        gif.on('finished', blob => { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'match-cut.gif'; a.click(); setStatus('idle'); setIsPlaying(true); });
                        gif.render();
                    } else {
                        const stream = canvas.captureStream(30); const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); const chunks = [];
                        recorder.ondataavailable = e => chunks.push(e.data);
                        recorder.onstop = () => { const blob = new Blob(chunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'match-cut.webm'; a.click(); setStatus('idle'); setIsPlaying(true); };
                        recorder.start();
                        for (let i = 0; i < validImages.length; i++) { 
                            drawFrame(ctx, validImages[i], dims.w, dims.h, false); // No guides
                            await new Promise(r => setTimeout(r, speed * 1000)); 
                        }
                        recorder.stop();
                    }
                } catch (e) { alert("Export failed"); setStatus('idle'); }
            };

            return (
                <div className="flex flex-col h-[100dvh] font-sans bg-[#f5f5f7] text-[#1d1d1f]">
                    {/* Header */}
                    <header className="h-16 flex items-center justify-between px-6 md:px-8 shrink-0 z-10 bg-[#f5f5f7] sticky top-0">
                        <div className="flex items-center gap-3">
                            <div className="w-10 h-10 bg-white shadow-sm rounded-full flex items-center justify-center border border-gray-100">
                                <IconGhost />
                            </div>
                            <span className="font-semibold text-2xl tracking-tight text-black">Match Cut</span>
                        </div>
                        <div className="flex items-center gap-4">
                            <div className="hidden md:flex items-center gap-3">
                                <SocialIcon type="github" />
                                <SocialIcon type="instagram" />
                                <SocialIcon type="gmail" />
                            </div>
                            <div className={`px-3 py-1.5 rounded-full text-xs font-bold tracking-wide flex items-center gap-1.5 ${modelReady ? 'bg-green-100 text-green-600' : 'bg-gray-200 text-gray-500'}`}>
                                <div className={`w-1.5 h-1.5 rounded-full ${modelReady ? 'bg-green-500' : 'bg-gray-400'}`}></div>
                                {modelReady ? 'READY' : 'LOADING'}
                            </div>
                        </div>
                    </header>

                    {/* Main Layout */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden p-4 md:p-6 gap-6">
                        
                        {/* Canvas Area (Resizable with Transition) */}
                        <div className="w-full h-[45vh] md:h-full md:flex-1 relative flex items-center justify-center perspective-1000">
                            {/* Animated Container for Ratio Switching */}
                            <div 
                                className={`relative squircle shadow-2xl overflow-hidden border border-black/5 bg-[#121212] transition-all duration-500 ease-spring ${RATIOS[ratio].aspect}`}
                                style={{ maxHeight: '100%', maxWidth: '100%' }}
                            >
                                <canvas ref={canvasRef} className="w-full h-full object-contain" />
                                
                                {/* Overlay Controls */}
                                <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex items-center gap-4 px-6 py-2.5 bg-zinc-900/40 backdrop-blur-xl rounded-full text-white/90 shadow-2xl border border-white/5 transition-transform hover:scale-105 duration-200">
                                    <button onClick={() => setIsPlaying(!isPlaying)} className="hover:text-white transition-colors">
                                        {isPlaying ? <IconPause /> : <IconPlay />}
                                    </button>
                                    <span className="font-mono text-xs font-medium opacity-60">
                                        {validImages.length > 0 ? (previewIndex % validImages.length) + 1 : 0} / {validImages.length}
                                    </span>
                                </div>
                            </div>
                        </div>

                        {/* Controls Area */}
                        <div className="w-full md:w-[400px] flex flex-col h-full overflow-y-auto pb-6">
                            <div className="space-y-6">
                                
                                {/* Upload Box */}
                                <div 
                                    onClick={() => fileInputRef.current.click()}
                                    onDragEnter={handleDragEnter} onDragLeave={handleDragLeave} onDragOver={e => e.preventDefault()} onDrop={onDrop}
                                    className={`group h-32 squircle bg-gray-100 border border-transparent flex flex-col items-center justify-center text-center cursor-pointer transition-all hover:bg-white hover:shadow-md hover:scale-[1.01] duration-300
                                        ${isDragging ? 'bg-blue-50 border-blue-400' : ''}`}
                                >
                                    <input type="file" multiple accept="image/*" ref={fileInputRef} className="hidden" onChange={e => handleFiles(e.target.files)} />
                                    <div className="text-lg font-semibold text-gray-900 mb-1">Tap to add photos,</div>
                                    <div className="text-sm text-gray-500">Processed locally for your privacy.</div>
                                    {images.length > 0 && (
                                        <div className="mt-2 text-[10px] font-bold text-blue-600 bg-blue-100/50 px-2 py-0.5 rounded-full animate-fade-in">
                                            {images.length} Loaded
                                        </div>
                                    )}
                                </div>

                                {/* Size & Guides */}
                                <div className="flex items-center justify-between px-1">
                                    <div className="flex items-center gap-4">
                                        <span className="text-xs font-bold text-gray-500 uppercase tracking-wide">SIZE</span>
                                        <div className="flex bg-white shadow-sm border border-gray-100 p-1 rounded-xl">
                                            {Object.keys(RATIOS).map(r => (
                                                <button key={r} onClick={() => setRatio(r)} 
                                                    className={`px-3 py-1 rounded-lg text-xs font-semibold transition-all duration-300 ease-out ${ratio === r ? 'bg-black text-white shadow-md transform scale-105' : 'text-gray-500 hover:text-gray-900'}`}>
                                                    {r}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-3">
                                        <span className="text-xs font-bold text-gray-500 uppercase tracking-wide">GUIDES</span>
                                        {/* --- UPDATED: Circular Checkbox --- */}
                                        <div className="flex items-center justify-center">
                                            <input 
                                                type="checkbox" 
                                                checked={showGuides} 
                                                onChange={() => setShowGuides(!showGuides)} 
                                                className="checkbox-circle"
                                            />
                                        </div>
                                    </div>
                                </div>

                                {/* Playback Speed */}
                                <div className="space-y-3 px-1">
                                    <div className="flex justify-between items-center">
                                        <span className="text-xs font-bold text-black uppercase tracking-wide">PLAYBACK SPEED</span>
                                        <span className="text-xs text-gray-500 font-medium font-mono">SPEED {speed}s</span>
                                    </div>
                                    <input type="range" min="0.05" max="1.0" step="0.05" value={speed} onChange={e => setSpeed(parseFloat(e.target.value))} />
                                </div>

                                {/* Layout Scale & Export Row */}
                                <div className="grid grid-cols-2 gap-8 px-1">
                                    <div className="space-y-3">
                                        <div className="flex justify-between items-center">
                                            <span className="text-xs font-bold text-black uppercase tracking-wide">LAYOUT SCALE</span>
                                            <span className="text-xs text-gray-500 font-medium font-mono">{layoutScale}%</span>
                                        </div>
                                        <input type="range" min="10" max="100" step="1" value={layoutScale} onChange={e => setLayoutScale(parseInt(e.target.value))} />
                                    </div>
                                    <div className="space-y-3">
                                        <span className="text-xs font-bold text-black uppercase block text-right tracking-wide">EXPORT</span>
                                        <div className="flex justify-end">
                                            <div className="flex bg-white border border-gray-200 p-1 rounded-xl shadow-sm">
                                                {['GIF', 'MP4'].map(f => (
                                                    <button key={f} onClick={() => setFormat(f)} className={`px-3 py-1.5 rounded-lg text-xs font-bold transition-all duration-300 ${format === f ? 'bg-gray-100 text-black shadow-inner transform scale-105' : 'text-gray-400 hover:text-gray-600'}`}>{f}</button>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Alignment Buttons */}
                                <div className="space-y-2 pt-2">
                                    <span className="text-xs font-bold text-black uppercase px-1 tracking-wide">ALIGNMENT MODE</span>
                                    <div className="grid grid-cols-2 gap-4">
                                        <button 
                                            onClick={() => setCropMode('smart')}
                                            className={`h-14 squircle text-sm font-semibold flex items-center justify-center gap-2 transition-all duration-300 shadow-md text-white overflow-hidden relative
                                            ${cropMode === 'smart' ? 'texture-bg ring-2 ring-offset-2 ring-blue-500 transform scale-[1.02]' : 'bg-gray-800'}`}
                                        >
                                            <span className="relative z-10 flex items-center gap-2"><IconSparkles /> Smart Crop</span>
                                        </button>
                                        <button 
                                            onClick={() => setCropMode('crop')}
                                            className={`h-14 squircle text-sm font-semibold flex items-center justify-center gap-2 transition-all duration-300 border shadow-sm
                                            ${cropMode === 'crop' ? 'bg-white border-blue-500 text-blue-600 ring-1 ring-blue-500 transform scale-[1.02]' : 'bg-white border-gray-200 text-gray-700 hover:bg-gray-50'}`}
                                        >
                                            <IconCrop /> Crop
                                        </button>
                                    </div>
                                </div>

                                {/* Export Button */}
                                <button 
                                    onClick={handleExport} 
                                    disabled={status !== 'idle' || validImages.length < 2}
                                    className="w-full h-16 texture-bg text-white squircle font-bold text-lg flex items-center justify-center gap-3 shadow-xl hover:shadow-2xl hover:scale-[1.02] active:scale-[0.98] transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed mt-4"
                                >
                                    {status === 'exporting' ? 
                                        <><IconLoader /> Exporting {exportProgress}%</> : 
                                        <><IconDownload /> Export Video</>
                                    }
                                </button>
                                
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
